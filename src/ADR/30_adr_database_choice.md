# ADR-001: Выбор базы данных PostgreSQL

**Статус**: Принято  
**Дата**: 2025-11-18  
**Авторы**: Архитектурная команда  
**Теги**: database, storage, PostgreSQL

---

## Контекст и формулировка проблемы

Системе умного КПП требуется надежное хранилище данных для:
- Метаданных пользователей (персональные данные, роли, права доступа)
- Биометрических данных (face embeddings - векторы 512-dim)
- Истории событий (логи проходов, распознаваний, решений)
- Конфигурации системы (правила доступа, настройки камер)

**Требования**:
- ACID транзакции (критично для целостности биометрии)
- Поддержка сложных запросов с JOIN
- Поддержка JSON для гибких метаданных
- Высокая производительность (10K+ транзакций/день)
- Репликация для высокой доступности
- Зрелость и стабильность решения

---

## Рассмотренные варианты

### Вариант 1: PostgreSQL (ВЫБРАН)
**За**:
- Полная поддержка ACID транзакций
- Расширение pg_vector для векторных данных (embeddings)
- Нативная поддержка JSONB (гибкие метаданные)
- Партиционирование таблиц (для истории событий)
- Streaming replication (master-slave для HA)
- Богатая экосистема инструментов (pgAdmin, PgBouncer)
- Открытый исходный код, активное сообщество
- Проверенная надежность в production

**Против**:
- Сложнее в настройке по сравнению с MySQL
- Горизонтальное масштабирование требует дополнительных решений (Citus)

### Вариант 2: MongoDB
**За**:
- Гибкая схема (JSON документы)
- Горизонтальное масштабирование (sharding)
- Хорошая производительность для чтения

**Против**:
- Слабые ACID гарантии (до версии 4.0)
- Нет встроенной поддержки векторных данных
- Сложные JOIN операции менее эффективны
- Риски потери данных при отказе (документированные инциденты)

### Вариант 3: MySQL
**За**:
- Широко распространен, простота администрирования
- ACID транзакции (InnoDB)
- Репликация master-slave

**Против**:
- Нет pg_vector эквивалента для embeddings
- Менее гибкая поддержка JSON (по сравнению с JSONB)
- Слабее в сложных аналитических запросах

---

## Решение

**Выбран PostgreSQL** как основная реляционная база данных.

**Архитектурное решение**:
- **PostgreSQL 15+** с расширениями:
  - `pg_vector` для хранения и поиска face embeddings
  - `pg_stat_statements` для мониторинга производительности
  - `pg_cron` для автоматических задач (архивация, cleanup)

- **Репликация**: Master-Replica (Streaming Replication)
  - 1 Primary (master) - все записи
  - 1 Replica (slave) - read-only запросы (отчеты, аналитика)
  - Automatic failover с использованием Patroni

- **Connection Pooling**: PgBouncer
  - Снижение нагрузки на PostgreSQL
  - Управление пулом соединений

- **Партиционирование**:
  - Таблица `events` партиционирована по месяцам (range partitioning)
  - Автоматическое создание партиций через pg_cron

---

## Обоснование

1. **ACID критичны**: Биометрические данные должны быть консистентны. Недопустима ситуация, когда пользователь зарегистрирован в `users`, но embeddings не сохранены в `biometrics`. PostgreSQL гарантирует atomicity транзакций.

2. **pg_vector для embeddings**: Расширение pg_vector позволяет хранить векторы и выполнять similarity search (L2, cosine) прямо в БД. Хотя для production мы используем Faiss (быстрее), pg_vector - отличный backup и для аналитики.

3. **JSONB для гибкости**: Метаданные событий (например, результаты распознавания) имеют переменную структуру. JSONB в PostgreSQL позволяет хранить и индексировать JSON с высокой производительностью.

4. **Зрелость решения**: PostgreSQL - проверенная временем СУБД с 30-летней историей. Используется в критичных системах (финтех, healthcare, government).

5. **Экономическая эффективность**: Open-source, нет лицензионных сборов. Сильное сообщество и бесплатные инструменты.

---

## Последствия

### Позитивные:
- Высокая надежность хранения данных
- Гибкость в моделировании данных (реляционные + JSON)
- Возможность сложных аналитических запросов
- Простота резервного копирования и восстановления
- Интеграция с популярными ORM (SQLAlchemy, Django ORM)

### Негативные:
- Требуется квалифицированный DBA для production setup
- Vertical scaling limit (~10M+ записей в одной таблице требует партиционирования)
- Backup и restore могут занимать время на больших объемах данных

### Риски и митигации:

**Риск 1**: Производительность падает при росте данных (>100GB)  
**Митигация**: 
- Партиционирование таблиц по времени
- Архивация старых данных в cold storage (MinIO)
- Индексы на горячих данных
- Query optimization (EXPLAIN ANALYZE)

**Риск 2**: Single point of failure (primary узел)  
**Митигация**:
- Streaming replication (1 replica минимум)
- Automatic failover (Patroni + etcd/Consul)
- Регулярные бэкапы (pg_dump + WAL archiving)

---

## Альтернативные решения для специфических задач

Хотя PostgreSQL - основная БД, для специфических задач используются дополнительные хранилища:

1. **Redis** (кэш) - для горячих данных (права доступа, user profiles)
2. **Faiss** (vector DB) - для быстрого similarity search embeddings
3. **Elasticsearch** - для полнотекстового поиска событий и логов
4. **MinIO** (S3) - для хранения изображений и видео

Это соответствует принципу **Polyglot Persistence** - использование разных хранилищ для разных типов данных.

---

## Связанные решения

- [ADR-003: Выбор Apache Kafka как message broker](./30_adr_kafka_broker.md)

---

## Ссылки

- [PostgreSQL Official Documentation](https://www.postgresql.org/docs/)
- [pg_vector Extension](https://github.com/pgvector/pgvector)
- [Patroni - HA solution for PostgreSQL](https://github.com/zalando/patroni)
- [PostgreSQL High Availability](https://www.postgresql.org/docs/current/high-availability.html)

---

**Последнее обновление**: 2025-11-18
